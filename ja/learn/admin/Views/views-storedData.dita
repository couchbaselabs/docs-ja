<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic xml:lang="ja" id="topic7568">
  <title>Viewと保存データ</title>
  <shortdesc>このセクションはViewシステムが保存データと関連してどのように動作するのかを解説します。</shortdesc>
  <body>
		<p>
			Viewシステムはクラスタ内にJSONドキュメント形式で保存されている情報に依存しています。
			この形式でデータをフォーマットすることで、データ内の各フィールドを特定でき、インデックスのコンポーネントで利用できます。
		</p>
		<p>
			Couchbaseデータベースに情報が保存されると、保存されたデータはパースされ、有効なJSONだと特定されると、有効なJSONとしてデータベース内で特定され、タグ付けられます。
			情報が有効なJSONとしてパースできない場合、送信されたデータのコピーを文字通りバイナリとして保存します。
		</p>
    
    <fig><image href="../images/view-types-datastore.png" width="600"></image></fig>
    
    <p>保存したデータを取得する際、情報のフォーマットはデータが有効なJSONとしてタグ付けされているかどうかに依存します:</p>
    
    <section><title>JSON情報</title>
    
			<p>
				JSONとして判定された情報は保存された状態と同一の形式で返却されます。
				この情報は意味的に同一で、送信された状態と同じフィールド、データ、構造で返却されます。
				Viewの処理中には、ドキュメントのメタデータ情報が別の構造として提供され、利用できます。
			</p>
    <p>空白文字、フィールドの順序は送信されたバージョンのJSONドキュメントと異なる場合があります。</p>
		<p>例えば、以下のJSONドキュメントを<codeph>mykey</codeph>のキーで保存します:</p>

    <codeblock>
{
   "title" : "Fish Stew",
   "servings" : 4,
   "subtitle" : "Delicious with fresh bread"
}
</codeblock>

    <p>Viewプロセッサ内では以下の様に返される場合があります:</p>
    <codeblock>
{
    "servings": 4,
    "subtitle": "Delicious with fresh bread",
    "title": "Fish Stew"
}
    </codeblock>
    </section>
    
    <section><title>JSON以外の情報</title>
    
			<p>
				JSONとしてパースできない情報は常にデータベースに送信された情報のバイナリコピーとして保存され、返却されます。
				例えば、画像を保存すると、保存された画像と同一のバイナリコピーが返されます。
			</p>
			<p>
				JSON以外のデータはbase64文字列としてView処理中に利用できます。
				JSON以外のドキュメントはメタデータ構造の<codeph>type</codeph>フィールドを参照し特定できます。
			</p>
    <p>返却された構造は、WebコンソールでのView編集時に確認できます。</p>
    </section>
    
    
    <section><title>JSONの基本</title>
			<p>
				JSONは軽量で、容易にパースでき、クロスプラットフォームなデータ表現形式です。
				ブラウザを含む全てのプラットフォームと全ての言語、アプリケーションフレームワークで、JSON形式のデータを扱い、開発者の仕事を効率的に助けるために設計された多くのライブラリやツールが存在します。
			</p>
      <p>JSONはJavaScriptでサポートされる基本的な型をサポートしています:</p>
      <ul>
        <li>Number (整数もしくは浮動小数)</li>
      </ul><p>JavaScriptがサポートする最大の数値は2<sup>53</sup>です。クライアントライブラリの環境でこれより大きな数字（例えば、64-bitの数字）を扱う場合は、文字列として値を保存する必要があります。</p><ul>
        <li><p>String — 二重引用符で囲まれた文字とUnicode文字やバックスラッシュエスケープをサポートします。例:</p>
          <codeblock>"A String"</codeblock></li>
				<li><p>Boolean — <codeph>true</codeph>もしくは<codeph>false</codeph>の値です。
				これらの文字列を直接利用できます。例:</p><codeph>{ "value": true}</codeph></li>
        <li><p>Array — 角かっこで囲まれた値のリストです。例:</p>
          <codeph>["one", "two", "three"]</codeph></li>
				<li><p>Object — キー/値ペアのセット(すなわち、連想配列、またはハッシュ)です。
					キーは文字列でなければなりませんが、値はJSONでサポートされている全ての値を利用できます。例:</p>
          <codeblock>{
   "servings" : 4,
   "subtitle" : "Easy to make in advance, and then cook when ready",
   "cooktime" : 60,
   "title" : "Chicken Coriander"
}
</codeblock></li>
      </ul>
      <p>キーは文字列でなければなりませんが、値はJSONでサポートされている全ての値を利用できます。</p></section>
    
    
    <section><title>ドキュメントメタデータ</title>
			<p>ビューの処理中に、各ドキュメントのメタデータは、独立したJSONオブジェクト<codeph>meta</codeph>として参照でき、オプションで<codeph>map()</codeph>関数の第二引数として定義されています。このメタデータは処理中のドキュメントを識別、特定するために利用することができます。</p>
			<p><codeph>meta</codeph>構造には、次のフィールド、及び関連情報が含まれています:</p>
      <ul>
        <li><codeph>id</codeph></li>
      </ul><p>保存データオブジェクトのID、あるいはキーです。Couchbaseデータベースにオブジェクトを書き込んだ際に指定したキーと同じです。</p><ul>
        <li><codeph>rev</codeph></li>
      </ul><p>情報の現在のリビジョンを記録するために、内部で利用されるリビジョンIDです。このフィールドに格納された情報は一貫性がなく、追跡もできないので、クライアントアプリケーションからは利用すべきではありません。</p><ul>
        <li><codeph>type</codeph></li>
				</ul><p>格納されたデータのタイプを指定します。有効なJSONドキュメントには<codeph>json</codeph>タイプが設定されます。
				バイナリデータとして識別されたドキュメントは<codeph>base64</codeph>タイプが設定されます。</p><ul>
        <li><codeph>flags</codeph></li>
				</ul><p>データが保存されたときに設定されたフラグの数値です。
				フラグの値の利用可否と値はデータを保存する際に利用しているクライアントライブラリに依存します。
				内部的にフラグは32ビット整数として格納されます。</p><ul>
        <li><codeph>expiration</codeph></li>
      </ul>
			<p>格納されたオブジェクトの有効期限の値です。
				有効期限は常に絶対的なUnixエポック時間として保存されています。</p>
			<p>これらの付加的なフィールドはViewサーバでドキュメントを処理している間だけ参照できます。
				これらのフィールドはMemcached/Couchbaseプロトコルを介してオブジェクトにアクセスしても、ドキュメントの一部としては返却されません。</p>
    </section>
    
    
		<section><title>JSON以外のデータ</title>
			<p>
				Couchbaseに保存された全てのドキュメントはJSON構造を返しますが、サブミットされた情報でJSONドキュメントとしてパースできたものだけがJSONドキュメントとして保存されます。
				JSONドキュメントにパースできない値を保存した場合、オリジナルのバイナリデータが保存されます。
				これは、<codeph>map()</codeph>関数に与えられる<codeph>meta</codeph>オブジェクトを使用して、ビューの処理中に識別することができます。
				JSONドキュメントではなく、バイナリドキュメントとして識別され、保存されているドキュメントであっても、ビューシステムにより、キーのデータを利用してインデックスを作成することができます。
				ドキュメントのキーが意味を持つ場合に特に有効です。
				たとえば、レコードのタイプを識別するために、キーにプレフィックスを付けている場合、ドキュメントのタイプでインデックスを作成できます。
		</p></section>
    
    
		<section><title>ドキュメントストレージとインデックスの処理順序</title><p>
				Couchbase Serverへ情報が格納される手順は、どのように、どのタイミングで情報のインデックスが作成されるのかに影響をあたえ、インデックスとデータがクラスタに保存されるタイミングは関連しています。
				加えて、データのインデクシングはViewシステムとそのViewへアクセスする際の設定が影響します。
			</p>
      
      
      
      
      <p>基本的なデータ保存とインデクシングの順序は以下のようになります:</p>
      
      
      
      <ol>
        <li>ドキュメントがクラスタに保存されます。まず、RAM上にのみドキュメントが保存されます。</li>
        <li>ドキュメントはレプリケーションを通してインデクサへと渡され、Viewによりインデクシングされます。</li>
      </ol>
      
			<p>
				この処理順序は、インデクサへと変更がレプリケートされるレイテンシをベースとして、メモリに保存されている情報とViewの実行結果の間には結果整合性があることを意味します。
				クラスタに新規にドキュメントを保存したあと、インデックスにアクセスすると、新規に保存されたドキュメントが生成されたView内に出現しない可能性があります。
			</p>
        
      
			<p>
				また、期限切れチェック処理によってデータベースから削除されるまで、有効期限付きのドキュメントがビューインデックス内に存在し続ける場合もあります。
			</p>
      
			<p>
				Couchbase ServerはObserveコマンドをサポートしており、対象のドキュメントがインデクサにレプリケートされたか、インデックスに含まれているかどうかといった、ドキュメントの現在の状態を確認することができます。
			</p>
			<p>Viewにアクセスする際、Viewの内容は保存されているドキュメントとは非同期です。
				加えて、ビューの作成や変更は<option>stale</option>パラメータに依存します。 
				これはViewのコンテンツをクエリする際に、Viewをいつ、どのように更新するのかを制御します。
      </p>
    </section>
    
  </body>
  <related-links>
    <linklist>
      <link href="../Views/views-operation.dita"/>
    </linklist>
  </related-links>
  
</topic>
