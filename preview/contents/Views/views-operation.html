<!DOCTYPE html><html xmlns:related-links="http://dita-ot.sourceforge.net/ns/200709/related-links" class="no-js developer-portal" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>Viewの動作</title><meta name="apple-mobile-web-app-title" content="Couchbase"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png"><link rel="stylesheet" href="../assets/stylesheets/application.css"><link rel="stylesheet" href="../assets/stylesheets/docs.css"></head><body data-modules="developer-portal-sidebar-navigation developer-portal-versions-navigation"><header class="developer-portal-header" role="banner"><div class="layout-wrapper"><div class="developer-portal-header__hgroup"><h1 class="developer-portal-header__logo"><a href="http://couchbase.com" rel="home">Couchbase</a></h1><p class="developer-portal-header__page-title">Couchbase Server</p></div><nav class="developer-portal-header__navigation" id="primary-navigation" role="navigation"><div class="developer-portal-header__navigation__wrapper" id="primary-navigation__wrapper"><a href="http://www.couchbase.com/learn" class="developer-porta-header__navigation__back">
							Return to Learn
						</a><ul class="developer-portal-header__navigation__items"><li class="developer-portal-header__navigation__item"><a href="/developer">Developer Documentation</a></li><li class="developer-portal-header__navigation__item"><a href="http://developer.couchbase.com/mobile">Couchbase Mobile</a></li><li class="developer-portal-header__navigation__item"><a href="http://www.couchbase.com/open-source">Open Source Projects</a></li><li class="developer-portal-header__navigation__item"><a href="http://forums.couchbase.com">Forums</a></li><li class="developer-portal-header__navigation__item"><a href="http://docs.couchbase.com/archive-index">Documentation Archives</a></li></ul><div class="developer-portal-header__search"></div></div></nav></div></header><main class="developer-portal-global-content" role="main"><aside class="developer-portal-sidebar"><div class="developer-portal-sidebar__versions"><ul id="developer-portal-versions-navigation"><li class="active"><a href="#"><span>Version 3.0</span></a></li><li class=""><a href="http://docs.couchbase.com/archive-index"><span>Older</span></a></li></ul></div><nav class="developer-portal-sidebar__navigation"><div class="developer-portal-sidebar__navigation__wrapper" id="developer-portal-sidebar-navigation"><ul><li class="section section--has-sub-sections"><a href="../Couchbase-intro.html"><span>はじめに</span></a></li><li class="section"><a href="../Whats-new-3.0.html"><span>3.0の新機能</span></a></li><li class="section section--has-sub-sections"><a href="../install-intro.html"><span>インストールとアップグレード</span></a></li><li class="section section--has-sub-sections"><a href="../admin-intro.html"><span>Couchbase Serverの管理</span></a></li><li class="section section--has-sub-sections section--active"><a href="../Views/views-intro.html"><span>Viewとインデックス</span></a><ul class="sub-sections"><li class="section"><a href="../Views/views-basics.html"><span>Viewの基本</span></a></li><li class="section"><a href="../Views/views-index-updates.html"><span>ストリームベースのView</span></a></li><li class="section"><a href="../Views/views-operation.html" class="current"><span>Viewの動作</span></a><ul class="sub-sections"></ul></li><li class="section"><a href="../Views/views-storedData.html"><span>Viewと保存データ</span></a></li><li class="section"><a href="../Views/views-development.html"><span>開発View</span></a></li><li class="section"><a href="../Views/views-production.html"><span>プロダクションView</span></a></li><li class="section"><a href="../Views/views-writing.html"><span>Writing views</span></a></li><li class="section"><a href="../Views/views-geospatial.html"><span>Writing geospatial views</span></a></li><li class="section"><a href="../Views/views-schemaless.html"><span>Views in a schema-less database</span></a></li><li class="section"><a href="../Views/views-translateSQL.html"><span>Translating SQL to map/reduce</span></a></li><li class="section"><a href="../Views/views-querying.html"><span>Querying views</span></a></li><li class="section"><a href="../Views/views-querySample.html"><span>View and query examples</span></a></li><li class="section section--has-sub-sections"><a href="../Misc/sample-bucket-intro.html"><span>Sample buckets</span></a></li></ul></li><li class="section section--has-sub-sections"><a href="../cli-intro.html"><span>CLIリファレンス</span></a></li><li class="section section--has-sub-sections"><a href="../rest-intro.html"><span>REST APIリファレンス</span></a></li><li class="section section--has-sub-sections"><a href="../rel-notes/rel-notes3.0.html"><span>Release notes</span></a></li></ul></div></nav></aside><div class="developer-portal-content"><div class="developer-portal-content__wrapper textblock__content">
 <h1 class="title topictitle1">Viewの動作</h1>

  
 <div class="body"><p class="shortdesc">このセクションではView動作や様々なViewやデータに関連する機能を説明します。</p>

  <p class="p">Couchbase内の全てのViewは以下の様に動作します:</p>

  <ul class="ul">
		<li class="li">ドキュメントデータがメモリ上で更新される際にViewが更新されます。
			ドキュメントが作成、更新されるタイミングと、ドキュメントがView内で更新されるタイミングの間には、
			クライアント側でのクエリパラメータに依存して遅延が発生します。</li>

		<li class="li">有効期限を指定して保存したドキュメントはバックグラウンドの期限切れドキュメント削除プロセスがデータベースからそれらを削除するまで、
			自動的に削除されません。
			このため、インデックス内に期限切れのドキュメントが残る場合があります。
		</li>

		<li class="li">Viewはデザインドキュメント内で定義され、各デザインドキュメントは単一のバケットの一部です。
		Viewは対応するバケット内の情報にのみアクセスできます。</li>

	<li class="li">View名は一つ以上のUTF-8文字で指定する必要があります。
		View名を空白にすることはできません。
		View名の前後には空白文字(スペース、タブ、改行)を含めることはできません。
	</li>

	<li class="li">UTF-8でエンコードできないドキュメントIDは自動的にフィルタリングされ、いかなるViewにも含まれません。
	フィルタリングされたドキュメントはログに出力されます。</li>

   <li class="li">複雑なViewリクエストを送信する場合、GETではなくPOSTを利用します。</li>

	 <li class="li">Viewを定義した、対応するバケット内のドキュメントにのみアクセス可能です。
	 複数のバケットのデータへアクセスしたり、集約することはできません。</li>

 <li class="li">Viewはデザインドキュメントの一部として作成し、デザインドキュメントは対応するバケットの内部に存在します。
	 <ul class="ul">
          <li class="li">各デザインドキュメントは0からn個のViewを持ちます。</li>

          <li class="li">各バケットは0からn個のデザインドキュメントを持ちます。</li>

        </ul>
</li>

				<li class="li">単一のデザインドキュメント内にある全てのViewは、単一のViewの更新が発動した時に同時に更新されます。
				例えば、3つのViewを持つデザインドキュメントは、1つのViewが更新されると同時に3つ全てのViewを更新します。</li>

   <li class="li">更新は二つの方法で実行できます:<ul class="ul">
     <li class="li">
			 <p class="p"><samp class="ph codeph">stale</samp>パラメータを指定してアクセス、クエリを実行した時。</p>

     </li>

     <li class="li">
			 <p class="p">更新されたドキュメントの数、および最終更新時からの経過時間に応じてCouchbase Serverが自動的に実施。
			 自動更新はグローバルに、あるいは個々のデザインドキュメント単位に制御できます。</p>

     </li>

    </ul>
</li>

		<li class="li"><p class="p">Viewはインクリメンタルに更新されます。
				初めてViewにアクセスすると、バケット内の全てのドキュメントがmap/reduce関数で処理されます。
		その後のViewに対する各アクセスでは、最後にViewインデックスを更新してから、追加、更新、削除されたドキュメントのみを処理します。</p>
</li>

  </ul>

	<p class="p">このため、Viewは完全にインクリメンタルな性質を持ちます。
		Viewの更新は変更したドキュメントのみを更新するため、通常高速です。
	ビルトインの自動更新システム、クライアントからの実行、アプリケーションフレームワークでの明示的な更新などで、Viewが更新されていることを確実にしてください。</p>

  <ul class="ul">
		<li class="li"><p class="p">Viewの更新処理はインクリメンタルな性質を持つため、情報はディスクに保存されたインデックスに追記されるだけです。
				このため、インデックスの更新は効率的に行われます。
				コンパクション(自動コンパクションを含む)はディスク上のインデックスサイズ、インデックス構造を最適化します。
		最適化したインデックスはより効率的に更新、クエリが可能です。</p>
</li>

	  <li class="li"><p class="p">View定義を変更すると、View全体が再作成されます。
	  これは利用中のデータに害をもたらす可能性があるため、開発Viewのみが変更可能です。</p>
</li>

  </ul>

	<p class="p">
		Viewはデザインドキュメントで組織され、インデックスはデザインドキュメントに基づき作成されます。
		複数のViewを持つデザインドキュメント内のあるViewを変更すると、そのデザインドキュメント内の全てのView(および保存されたインデックス)が無効化され、そのデザインドキュメント内に定義された関連する全てのViewを再構築しなければなりません。
		これは、アクティブなプロダクションViewで必要なI/Oに加え、インデックスの再構築のI/Oを増加させます。
	</p>

  <ul class="ul">
		<li class="li"><p class="p">
				Viewの結果の更新方法はクエリ実行前かクエリ実行後から選択できます。
				もしくは、クエリ実行時に、Viewが持つ現在の結果セットを取得することも可能です。
				この場合、結果が最新でない可能性があります。
		</p>
</li>

   <li class="li"><p class="p">Viewエンジンはインデックスをデザインドキュメントごとに作成します; このインデックスはそのデザインドキュメント内の全てのViewの結果を保持します。</p>
</li>

	 <li class="li"><p class="p">
			 このインデックス情報はディスクに保存され、Viewで定義したkeyとvalueの両情報から構成されます。
			 可能な限り高速に情報を返却できるようにkeyとvalueの値はインデックス内に保存され、同時にreduce関数を持つViewがインデックスからデータを抽出し集約できるようにしています。
	 </p>
</li>

  </ul>

	<p class="p">map関数で定義したkeyとvalueの情報はインデックス内に保存されているため、出力したkey/value情報がオリジナルのドキュメントデータよりも大きい場合、インデックスの総データサイズは保存データの総サイズよりも大きくなる場合があります。</p>

   
	<div class="section"><h2 class="title sectiontitle">有効期限がViewに与える影響</h2>
		<p class="p">
			Couchbase Serverは有効期限を遅延判定していることに注意してください、これは、期限切れのアイテムは即座に削除されるのではなく、削除状態でフラグ付けされるということです。
			Couchbase Serverは<em class="ph i">expiry pager</em>というメンテナンスプロセスを定期的に実行し、全ての情報を参照して期限切れのアイテムを削除します。
			このメンテナンスプロセスは実行間隔を変更していない場合、デフォルトでは60分ごとに実行されます。
			アイテムがリクエストされると、Couchbase Serverは削除用にフラグ付けされたアイテムを削除し、そのアイテムは存在しないというレスポンスを返します。
		</p>

		<p class="p">
			Viewの結果はViewに定義された条件に一致するいかなるアイテムも<em class="ph i">含みます</em>。
			このため、ディスクから削除されていない情報はViewクエリの結果内に現れることがあります。
			CouchbaseのViewを使うと、<em class="ph i">reduce関数</em>をデータに適用し、計算やデータの集約を実行することもできます。
			例えば、ある種別のオブジェクトインスタンスの数をカウントしたい場合、reduce関数を利用します。
			繰り返しになりますが、ディスク上に存在するアイテムはreduce関数で実行される全ての計算に含まれることになります。
			ディスク永続化に起因する挙動に対して、Viewで有効期限を処理するガイドラインを以下に記載します:
		</p>

    
    <ul class="ul">
    <li class="li"><p class="p"><strong class="ph b">結果セット内の期限切れドキュメントを検知する</strong>: Couchbase Server内のアイテムをインデクシングするためにViewを利用している場合、まだ期限切れページャメンテナンスプロセスにより削除されていないアイテムは、Viewクエリの結果セット内に含まれます。</p>
</li>

		<li class="li"><strong class="ph b">Reduceと期限切れアイテム</strong>
			: 時として、<em class="ph i">reduce関数</em>を実行し、Couchbase Server内のデータの集約や計算を行いたい場合があるでしょう。
			この場合、Couchbase Serverはインデックス用に保存されている、事前に計算された値を利用して、最終的な結果を導きます。
			これはまた、ディスク上にまだ存在する期限切れアイテムが計算の一部に含まれることを意味します。
			期限切れアイテムの割合がそうでないアイテムに比べて比較的低い場合、これが最終結果に影響を与えることはないかもしれません。
			例えば、100万人のプレイヤーにおける平均スコアを計算する際に、ディスク上に10の期限切れスコアが残っていたとしても、最終結果での違いはごくわずかでしょう。
			しかし、20人のプレイヤーにおける平均スコアを計算する際に、ディスク上に10の期限切れスコアが残っている場合、期待する平均値よりも大きく異なる結果となるでしょう。
		</li>

   </ul>

    
	 <p class="p">
		 この場合、より頻繁に期限切れページャプロセスを実行し、すでに期限切れとなっているアイテムがreduce関数内の計算に含まれないようにすることもできます。
		 クラスタ内の各ノード上の期限切れページャを10分ごとに実行することをお勧めします。
		 この間隔はノード上でクリーンアップをより頻繁に実行するので、ノード上の性能に僅かながら影響を与えることに留意してください。
	 </p>

	 <p class="p">
		 メンテナンスプロセスの実行感覚設定に関する詳細情報は、Couchbaseコマンドラインツールを参照し、<samp class="ph codeph">exp_pager_stime</samp>の例を確認してください。
	 </p>

  </div>

  
  
	<div class="section"><h2 class="title sectiontitle">クラスタ内Viewの挙動</h2><p class="p"><strong class="ph b">データの分散</strong>。
			Couchbase Serverをすでに利用しているなら、サーバがデータをクラスタ内の異なるサーバ間で分散していることをご存知でしょう。
			クラスタ内にノードが4台ある場合、平均して各ノードはアクティブデータの25%を保持します。
			Couchbase ServerのViewを利用すると、インデクシング処理は4つ全てのノード上で実行され、ディスク上のインデックスは結果の約25%を含みます。
			クラスタ内のデータの一部分を元にしているので、これらのインデックスを<em class="ph i">部分インデックス</em>とします。
			以下の図でこの部分インデックスを示します。
			</p>

			<p class="p"><strong class="ph b">データのレプリケーションとインデックス</strong>。
				Couchbase Serverはまた、データのレプリケーションを提供します; このため、サーバはあるノードから他のノードへとデータをレプリケートします。
				一つ目のノードがダウンしても、二つ目のノードが継続してそのデータに対するリクエストを処理できます。
				ノード障害に対応するため、Couchbase Serverにレプリカデータ用の部分インデックスもレプリケートするように指定できます。
				デフォルトではクラスタ内の各ノードは各デザインドキュメントとView関数のコピーを保持しています。
				View関数を変更すると、Couchbase Serverはその変更をクラスタ内の全てのノードにレプリケートします。
				サーバは単一のデザインドキュメント内のViewからインデックスを生成し、そのインデックスをクラスタ内各ノード上に単一のファイルとして保存します:
			</p>

   
   <div class="fig fignone"><img class="image" src="../images/views_replica.png" width="720"></div>

   
	 <p class="p">
		 Couchbase Serverはまた、レプリカデータを含むレプリカインデックスをノード上に作成することも可能です; これはクラスタでのフェイルオーバシナリオに対する準備のためです。
		 サーバは他のサーバからインデックス情報をレプリケートしません、代わりに、各ノードは保持するレプリカデータのインデックスを作成します。
		 サーバはノード上のレプリカデータを利用して、定義された各デザインドキュメントとViewのインデックスを再作成します。
		 レプリカインデックスにより、ノード障害が発生したとしてもクエリの実行が可能になります。
		 バケットの作成時にCouchbase Serverがレプリカインデックスを作成するか否かを指定できます。
	 </p>

   
   <p class="p"><strong class="ph b">クラスタでのクエリ実行</strong></p>

   
	 <p class="p">
		 Viewをクエリしインデクシング処理を実行するには、リクエストをクラスタ内にある一つのノードに送信します。
		 そのノードはリクエストをクラスタ内の全てのノードへと分配します。
		 クエリに設定するパラメータに応じて、各ノードはノードにおける現在の部分インデックスか、部分インデックスを更新して送信するか、部分インデックスを送信後にディスク上の部分インデックスを更新します。
		 Couchbase Serverはこれらの部分インデックスを収集し照合して、集約した結果をクライアントに送信します。
	 </p>

	 <p class="p">クエリ実行時のエラー処理として、エラー発生時のクラスタの挙動を設定できます。</p>

   
	 <p class="p"><strong class="ph b">リバランスおよびフェイルオーバ中のクエリ</strong></p>

	 <p class="p">クラスタのリバランスおよびノードのフェイルオーバ中でもインデックスをクエリできます。
		 リバランスやノード障害中にクエリを実行すると、Couchbase Serverはリバランスやノード障害が発生していない場合に期待されるようなクエリ結果を返すようにします。
	 </p>

	 <p class="p">リバランス中は、データがあるノードから他のノードへと移動していないかのように、ノード上のデータがアクティブである場合に期待される結果と同様の結果を返します。
		 言い換えると、この機能はリバランス中にも、あるノードからのクエリ結果と、リバランスを開始する前のノードから返されるクエリ結果との一貫性を保証するということです。
		 Couchbase Serverのデフォルトとしてこの機能は動作しますが、無効化することもできます。
		 この機能が有効な場合、クラスタのリバランスにはより長い時間がかかることに注意してください; しかし、一貫性のないクエリ結果となるため、この機能をテストすることなくプロダクション環境で無効化することは推奨しません。
 	 </p>
</div>

  
	 <div class="section"><h2 class="title sectiontitle">Viewの性能</h2><p class="p">
			 Viewの更新に必要な時間、Viewの更新へアクセスするための時間、そして更新された情報が返却されるまでの時間などのView性能はさまざまな要素に依存します。
			 ファイルシステムキャッシュ、更新頻度、ドキュメントデータ更新からViewへアクセス(もしくは更新)するまでの時間などはすべて性能に影響します。
		 </p>

   <p class="p">いくつかの重要な点を以下に記載します:</p>

   <ul class="ul">
		 <li class="li">
			 インデックスのクエリは常にディスクへとアクセスします; インデックスはCouchbase ServerによってRAM上に保持されていません。
			 しかし、頻繁に利用するインデックスは、ディスク上の情報をキャッシュするためのファイルシステムキャッシュに保存される場合があります。
			 利用可能な総RAM容量からCouchbase Serverに割り当てるRAMを削減し、ファイルシステムキャッシュを増加させると、OSで利用可能なRAMが増加します。
		 </li>

		 <li class="li">
			 ファイルシステムキャッシュはインデックス情報の更新処理においても重要な役割を担います。
			 最近更新されたドキュメントはファイルシステムキャッシュ内に保存されているでしょう。
			 更新操作の直後にViewの更新をリクエストすると、ファイルシステムキャッシュからの情報を使うことになるでしょう。
			 結果永続性の性質によりドキュメントの更新、永続化、インデックス内への反映までに若干の遅延があります。
		 </li>

   </ul>
オペレーティングシステム用のある程度のRAMを確保しておくことで、ファイルシステムキャッシュとして割り当てられるRAMを増加させ、インデックスファイルキャッシュに利用できる領域を確保するのに役立ちます。<ul class="ul">
	 <li class="li">
		 Viewインデックスはドキュメント更新システムとは完全に独立して保存、アクセス、更新されます。
		 このため、インデックス更新と参照はインデックス情報を構築するためにドキュメントがメモリに存在するかどうかに依存しません。
		 独立したシステムは、クラスタへアクセスし取得する性能が、ドキュメントストアに依存しないことも意味します。
	 </li>

   </ul>

  </div>

  
  
  <div class="section" id="topic22896__index-stale"><h2 class="title sectiontitle">インデックスの更新とstaleパラメータ</h2>
   
		<p class="p">
			インデックスはView定義に基づき、Couchbase Serverによって作成されますが、インデックスの更新はデータが挿入されるたびに実行するのではなく、データのクエリ時に制御できます。
			クエリ実行時にインデックスを更新するか否かは<samp class="ph codeph">stale</samp>パラメータで制御します。
			<samp class="ph codeph">stale</samp>パラメータに関わらず、ドキュメントはディスクに永続化された後にのみシステムでインデクシング可能となります。
			ドキュメントがまだディスクに永続化されていない場合、<samp class="ph codeph">stale</samp>を使用してもこの処理を強制することはできません。
			インデックスに反映されるように、<samp class="ph codeph">observe</samp>オペレーションを利用しドキュメントがディスクに永続化されることを監視できます。
			Viewはまた、ドキュメントの変更と更新間隔に応じて自動的に更新することもできます。
		</p>

   
		<p class="p"><samp class="ph codeph">stale</samp>では3つの値をサポートしています:</p>
<ul class="ul">
    <li class="li"><strong class="ph b">stale=ok</strong></li>

	</ul>
<p class="p">インデックスは更新されません。
	もしインデックスがViewに存在している場合、クエリ発行時点でのインデックス内の現在の情報が利用され、それに応じて結果を返します。</p>

   
   <div class="fig fignone"><img class="image" src="../images/views-stale-sequence-stale.png" width="720"></div>

   
	 <p class="p">この設定は既存のインデックスを更新せずに利用するため、最も高速にクエリのレスポンスを返します。
		 しかし、データベース内のドキュメントが変更されていても、Viewに含まれていない場合、不完全な情報を返すリスクがあります。</p>
<ul class="ul">
    <li class="li"><strong class="ph b">stale=false</strong></li>

   </ul>

   
	 <p class="p">
		 クエリ実行前にインデックスを更新します。
		 これは更新されたすべてのドキュメント(ディスクに永続化済み)がViewに含まれることを保証します。
		 クライアントはインデックスの更新が完了するまでクエリの実行を待つことになり、更新されたインデックスが利用可能になるまでレスポンスが遅延します。
	 </p>

   
   <div class="fig fignone"><img class="image" src="../images/views-stale-sequence-updatebefore.png" width="720"></div>

   
   <ul class="ul">
    <li class="li"><strong class="ph b">stale=update_after</strong></li>

	</ul>
<p class="p"><samp class="ph codeph">stale</samp>パラメータをしていしない場合のデフォルト設定です。
	クエリ時点の既存のインデックスが利用されますが、インデックスはクライアントに結果を返却した後に更新されるようにマークされます。</p>

   
   
   <div class="fig fignone"><img class="image" src="../images/views-stale-sequence-updateafter.png" width="720"></div>

   
   
	 <p class="p">
		 インデクシングエンジンは非同期なプロセスです; このため、インデックをクエリすると予期せぬ結果を返す可能性があります。
		 例えば、ドキュメントを更新した直後に、そのドキュメントを含むクエリを実行すると、更新後の情報が出力されたViewデータ内に含まれない可能性があります。
		 これはドキュメントの更新がインデックスの更新を実施した時点でまだディスクにコミットされていないためです。
		 削除したドキュメントがまだインデックスから削除されていないために、インデックス内に削除したドキュメントが出現する可能性もあります。
	 </p>

	 <p class="p">
		 どちらのシナリオでも、<samp class="ph codeph">observe</samp> コマンドを<samp class="ph codeph">persistto</samp>引数とともにクライアントで利用し、ドキュメントの永続化状態を確認してから、<samp class="ph codeph">stale=false</samp>を利用してViewの更新を強制的に行うべきです。
		 そうすればViewインデックス内に正しくそのドキュメントが反映されたことを保証できます。
	 </p>

	 <p class="p">
		 一つのインデックスに複数のクライアントがアクセスする場合、インデックス更新処理とクライアントに返却される結果は各クライアントがしていしたパラメータとクライアントがサーバとやりとりする順序に依存します。
	 </p>
<ul class="ul">
    <li class="li"><p class="p">シナリオ1</p>

     
     
		<ol class="ol">
			<li class="li">クライアント1が<samp class="ph codeph">stale=false</samp>でクエリを実行</li>

      <li class="li">クライアント1はサーバがインデックスを更新するのを待つ</li>

			<li class="li">クライアント1の処理中に、クライアント2が<samp class="ph codeph">stale=false</samp>でViewをクエリ</li>

      <li class="li">クライアント2はクライアント1によって開始された既存のインデックス処理完了を待つ。</li>

      <li class="li">クライアント2は更新されたインデックスを得る。</li>

    </ol>
</li>

    <li class="li"><p class="p">シナリオ2</p>

     <ol class="ol">
			<li class="li">クライアント1が<samp class="ph codeph">stale=false</samp>でViewをクエリ</li>

      <li class="li">クライアント1はサーバがインデックスを更新するのを待つ</li>

			<li class="li">クライアント1のインデックス更新が処理中に、クライアント2が<samp class="ph codeph">stale=ok</samp>でViewをクエリ</li>

      <li class="li">クライアント2は既存のインデックスを得る</li>

     </ol>
</li>

    <li class="li"><p class="p">シナリオ3</p>

     <ol class="ol">
			<li class="li">クライアント1が<samp class="ph codeph">stale=false</samp>でViewをクエリ</li>

      <li class="li">クライアント1はサーバのインデックスを更新を待つ</li>

			<li class="li">クライアント2が<samp class="ph codeph">stale=update_after</samp>でViewをクエリ</li>

      <li class="li">クライアント1のインデックス更新が完了していない場合、クライアント2は既存のインデックスを得る。</li>

      <li class="li">クライアント1のインデックス更新が完了している場合、クライアント2は更新されたインデックスを得て、さらにインデックス更新が開始される。</li>

     </ol>
</li>

   </ul>

   
	 <p class="p">
		 複数のクライアントがViewの更新を情報の返却前にリクエストすると(<samp class="ph codeph">stale=false</samp>)、インデックス更新はスタックすることがあります。
		 よって複数のクライアントがインデックスを更新およびインデックスデータのクエリを行うと更新されたドキュメントと各時点のViewを返すことを保証しています。
		 <samp class="ph codeph">stale=update_after</samp>のクエリでは、クエリがアクセスした後にすべての更新が発生するため、インデックスの更新はスタックされません。
	 </p>

   
   <p class="p">シーケンシャルなアクセス</p>

   
   <ol class="ol">
    <li class="li">クライアント1がstale=okでViewをクエリ</li>

    <li class="li">クライアント2がstale=falseでViewをクエリ</li>

    <li class="li">Viewが更新される</li>

    <li class="li">クライアント1が再びstale=okでViewをクエリ</li>

    <li class="li">クライアント1は更新されたViewを得る</li>

   </ol>
<p class="p">上記のシナリオはそれぞれのクエリ間でレコードの順序が変わる可能性があるため、複数のレコードをページ制御している場合に問題が起こる場合があります。</p>

  
  </div>

  
  
  <div class="section"><h2 class="title sectiontitle">インデックス更新の自動化</h2>
   
		<p class="p">
			更新間隔の設定に加え、すべてのインデックスをバックグラウンドで自動的に更新することもできます。
			自動更新はViewエンジンがインデックスを更新するまでの、更新間隔(ミリ秒)と変更されたドキュメントの数の二つのパラメータで制御できます。
			これら二つのパラメータは<samp class="ph codeph">updateInterval</samp>と <samp class="ph codeph">updateMinChanges</samp>です: 	</p>

   
   <ul class="ul">
		 <li class="li"><p class="p"><samp class="ph codeph">updateInterval</samp> : インターバルをミリ秒で指定、デフォルトは5000ミリ秒。
				 <samp class="ph codeph">updateInterval</samp>ごとにViewエンジンはディスク上のドキュメントの変更数が<samp class="ph codeph">updateMinChanges</samp>より多いかをチェックします。
				 そうであれば、Viewの更新を開始します。
				 ディスクに保存されたドキュメントはメモリ内のドキュメントと比べて数十秒遅れている可能性もあります。
		</p>
</li>

		<li class="li"><p class="p">
				<samp class="ph codeph">updateMinChanges</samp> : 再インデックス実施までに発生したドキュメント変更数で、デフォルトは5000です。
		</p>
</li>

   </ul>

   
	 <p class="p">
		 自動更新処理はフルセットの開発用およびプロダクション用インデックスでのみ実行されます。
		 自動更新は部分的な開発用インデックスでは実施されません。
	 </p>

	 <p class="p">
		 自動更新プロセスに関わらず、ドキュメントはディスクに永続化された後にのみシステムでインデックス可能となります。
		 ドキュメントがディスクに永続化されていなくても、自動更新処理は未書き込みのデータをディスクに強制的に書き込むことはしません。
		 <samp class="ph codeph">observe</samp>オペレーションを利用してドキュメントがディスクに永続化され、インデックスに反映されることを監視できます。
	 </p>

   
   <p class="p">更新は以下のように適用されます:</p>
<ul class="ul">
    <li class="li">アクティブインデックス、プロダクションView</li>

   </ul>

   
	 <p class="p">
		 すべてのアクティブ、プロダクションViewのインデックスは自動的に更新間隔<samp class="ph codeph">updateInterval</samp>と、ドキュメント変更数<samp class="ph codeph">updateMinChanges</samp>に応じて更新されます。
	 </p>

   
	 <p class="p"><samp class="ph codeph">updateMinChanges</samp>を0に設定すると、自動更新は無効化されます。</p>

   
   
   <ul class="ul">
    <li class="li">レプリカインデックス</li>

   </ul>

   
	 <p class="p">バケットでレプリカインデックスを有効にすると、ドキュメントの変更数設定(<samp class="ph codeph">replicaUpdateMinChanges</samp>; デフォルトは5000)に応じて自動的にインデックスを更新します。</p>

   
	 <p class="p"><samp class="ph codeph">replicaUpdateMinChanges</samp>を0に設定すると、レプリカインデックスの自動更新は無効化されます。</p>

	 <p class="p">これらの設定はグローバルに、あるいはREST APIを利用して各デザインドキュメント単位で設定することができます。</p>

   
	 <p class="p">現在のView更新デーモン設定を取得するには、クラスタ内のノードの管理用ポートに次のURLでアクセスします、<samp class="ph codeph">http://nodename:8091/settings/viewUpdateDaemon</samp> :</p>

   
   <pre class="pre codeblock"><code>GET http://Administrator:Password@nodename:8091/settings/viewUpdateDaemon
</code></pre>
<p class="p">現在の更新設定がJSONで返却されます:</p>

   
   <pre class="pre codeblock"><code>{
    "updateInterval":5000,
    "updateMinChanges":5000,
    "replicaUpdateMinChanges":5000
}
</code></pre>

   
<p class="p">
	設定を更新するには、変更する値を含むペイロードデータを<samp class="ph codeph">POST</samp>で渡します。
	例えば、更新間隔を10秒に、ドキュメントの変更数を7000に変更する場合:
</p>

   
   <pre class="pre codeblock"><code>POST http://nodename:8091/settings/viewUpdateDaemon
updateInterval=10000&amp;updateMinChanges=7000
</code></pre>

   
   <p class="p">成功すると、変更後の設定がJSONで返却されます。</p>

	 <p class="p"><samp class="ph codeph">updateMinChanges</samp>と<samp class="ph codeph">replicaUpdateMinChanges</samp>の設定を個別のデザインドキュメントで明示的に変更するには、デザインドキュメントの<samp class="ph codeph">options</samp>セクションにこれらのパラメータを指定します。例えば:</p>

   
   <pre class="pre codeblock"><code>{
   "_id": "_design/myddoc",
   "views": {
      "view1": {
          "map": "function(doc, meta) { if (doc.value) { emit(doc.value, meta.id);} }"
      }
   },
   "options": {
       "updateMinChanges": 1000,
       "replicaUpdateMinChanges": 20000
   }
}
</code></pre>
<p class="p">デザインドキュメントのREST APIを利用し、作成時や更新時にこれらの情報を設定できます。
<samp class="ph codeph">curl</samp>コマンドを利用してこの操作を実行するには:</p>

   
   <pre class="pre codeblock"><code>&gt; curl -X POST -v -d 'updateInterval=7000&amp;updateMinChanges=7000' \
    'http://Administrator:Password@192.168.0.72:8091/settings/viewUpdateDaemon'
</code></pre>

   
<p class="p">
	部分的な開発用Viewは自動的に再構築されず、Viewの一貫性を有効にしていても、Viewの一貫性は自動更新の仕組みに依存するため、リバランス実行中には開発用Viewは更新されません。
	開発用Viewをこの様に更新するのはシステムリソースの無駄遣いになるからです。
</p>

  
  </div>

  
  
 </div>

 <nav class="related-links"><h2>Related information</h2>
<div class="familylinks">
<div class="parentlink"><strong>親トピック:</strong> <a class="link" href="../Views/views-intro.html" title="CouchbaseのViewはデータをインデクシングしクエリを可能とします。">Viewとインデックス</a></div>
<div class="previouslink"><strong>前のトピック:</strong> <a class="link" href="../Views/views-index-updates.html" title="ストリームベースのViewはViewの更新レイテンシを削減し、より高速にViewの一貫性を保ち、最新のデータを提供します。">ストリームベースのView</a></div>
<div class="nextlink"><strong>次のトピック:</strong> <a class="link" href="../Views/views-storedData.html" title="このセクションはViewシステムが保存データと関連してどのように動作するのかを解説します。">Viewと保存データ</a></div>
</div>

<div class="linklist linklist">
<div><a class="link" href="views-querying.html" title="The content of the key that is generated by the emit() function provides information on how the data is selected from your view.">Querying views</a></div>
<div><a class="link" href="../Tasks/tasks-compaction.html" title="Database and view compaction helps to reclaim disk space and reduce fragmentation.">Compacting data files</a></div>
<div><a class="link" href="../REST/rest-views-intro.html" title="The Views REST API is used to index and query JSON documents.">Views API</a></div></div>
</nav>
</div><footer class="developer-portal-footer" role="contentinfo"><p class="legal"><span class="license">© 2011–2015 <b class="company-name">Couchbase</b> All rights reserved.</span><a href="http://www.couchbase.com/developers">Developer Portal</a><a href="http://forums.couchbase.com">Forums</a><a href="http://www.couchbase.com/downloads">Download</a><a href="http://support.couchbase.com/">Customer Support Login</a></p></footer></div></main><script src="../assets/javascripts/vendor/prism.js"></script><script type="text/javascript">var BASEPATH='../';</script><script src="../assets/javascripts/init.js"></script><script type="text/javascript" src="https://issues.couchbase.com/s/en_US-pvmaib-418945332/845/131/1.2.9/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?collectorId=86389172"></script></body></html>